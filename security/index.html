<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" href="style.css">
    <meta charset="UTF-8">
</head>
<body>

<h1>Lab 13: Security and Privacy Assessment of Ride-Hailing Service</h1>

<h2>Introduction</h2>
<p></p>
<h2>Methodology</h2>
<p></p>
<h2>Abstract of Findings</h2>
<p></p>
<h2>Issues Found</h2>
<p></p>

<div class="issue_div">
    <h3>Issue</h3>
    <p>Cross-site scripting (XSS)</p>
    <h3>Location</h3>
    <p><strong>Under the rides route (/rides)</strong>, line 27, where there is the INSERT query + <strong>under the root route (/ )</strong>, more specifically on lines 116 and 117, where the indexPage variable is updated.</p>
    <h3>Severity of issue</h3>
    <p>Since it is a stored XSS it is considered of a high or critical risk, as suggested by <a href="https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A7-Cross-Site_Scripting_(XSS)" target="_blank">OWASP</a>.</p>
    <h3>Description of issue</h3>
    <p> Under the /rides route, the passenger table of the database gets updated with a username that is not verifies, which can easily be substituted by a script tag. Under the root route (/), the indexPage variable contains the
        HTML that will be displayed on the index page. Since this html is generated by concatenating html tags with the username obtained from the passenger table, the script tag introduced earlier might obtain sensitive data from the user accessing the root route.</p>
    <h3>Proof of vulnerability</h3>
    In the terminal, executing
    <br><br>
    "curl -d 'username=&lt;script&gt;SOMETHING BAD&lt;script&gt;&lat=62&lng=70' https://jordan-marsh.herokuapp.com/"
    <br><br>
    will make the web server store the username, lat and lng provided by an attacker in the database. Later, if an user accesses the
    root route, and the server will successfully execute the following code
    <br><br>
    for (var count = 0; count < result.rows.length; count++) { indexPage += "&lt;li>" + result.rows[count].username + " requested a vehicle at " + result.rows[count].lat + ", " + result.rows[count].lng + " on " + result.rows[count].created_on + "&lt;/li>"; }"
    <br><br>
    then the attacker's script will be executed in the user's browser and possibly obtain sensitive data.
    </p>
    <h3>Resolution</h3>
    <p>To solve this issue, the developer of the web server should check for the validity of the username under the /rides route, so that it doesn't include script tags or other non-valid characters.</p>
    <h3>Conclusion</h3>
    <p>
        In order to avoid stored XSS, assure that the elements stored in the database are valid entries and not script tags. Also, before constructing html content from contents from a database, assure that the contents are valid and again they are not unexpected script tags.
    </p>
</div>
<hr>
<div class="issue_div">
    <h3>Issue</h3>
    <p>SQL Injection</p>
    <h3>Location</h3>
    <p>Under the /passenger.json and the /vehicle.json routes.</p>
    <h3>Severity of issue</h3>
    <p>It can be a very severe issue since, according to <a href="https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection" target="_blank">OWASP</a>, injection can result in data loss, corruption, or disclosure to unauthorized parties, loss of accountability, or denial of access. Injection can sometimes lead to complete host takeover. </p>
    <h3>Description of issue</h3>
    <p>Under the /passenger.json, since usernameEntry can be provided by an attacker and its validity is not checked anywhere, it will be combined with an SQL query later under the same route. The usernameEntry, instead of containing a valid username, it might contain a part of a SQL command. This might cause disclosure of data of other users.</p>
    <h3>Proof of vulnerability</h3>
    <p>An attacker could send a username in the request that is "username'OR1=1--", which will result in the SQL query being<br><br>
        SELECT * FROM passengers WHERE username = 'username' OR 1=1--;
        <br><br>
        since it will most probably happen that the username is not in the database, the second condition after the OR will be verified, which
        is always true. Thus, the database will return all the rows in teh database, hence revealing all the data in the passengers table to the attacker.
    </p>
    <h3>Resolution</h3>
    <p>Preventing injection requires keeping data separate from commands and queries.<br>
        * The preferred option is to use a safe API, which avoids the use of the interpreter entirely or provides a parameterized interface, or migrate to use Object Relational Mapping Tools (ORMs).
        Note: Even when parameterized, stored procedures can still introduce SQL injection if PL/SQL or T-SQL concatenates queries and data, or executes hostile data with EXECUTE IMMEDIATE or exec().<br>
        * Use positive or “whitelist” server-side input validation. This is not a complete defense as many applications require special characters, such as text areas or APIs for mobile applications.<br>
        * For any residual dynamic queries, escape special characters using the specific escape syntax for that interpreter.<br>
        Note: SQL structure such as table names, column names, and so on cannot be escaped, and thus user-supplied structure names are dangerous. This is a common issue in report-writing software.<br>
        * Use LIMIT and other SQL controls within queries to prevent mass disclosure of records in case of SQL injection.<br>
    Source: <a href="https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection" target="_blank">OWASP</a></p>
    <h3>Conclusion</h3>
    <p></p>
</div>

<div class="issue_div">
    <h3>Issue</h3>
    <p></p>
    <h3>Location</h3>
    <p></p>
    <h3>Severity of issue</h3>
    <p></p>
    <h3>Description of issue</h3>
    <p></p>
    <h3>Proof of vulnerability</h3>
    <p></p>
    <h3>Resolution</h3>
    <p></p>
    <h3>Conclusion</h3>
    <p></p>
</div>


</body>
</html>

